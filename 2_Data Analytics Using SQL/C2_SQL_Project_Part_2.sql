USE `modelcarsdb`;

-- Task 1 
-- 1) Find the total number of employeees.
select count(employeeNumber) as total_employee from employees;
-- Interpretation: This value will show the total number of employees 

-- 2) list all employees with their basic information
select employeeNumber, firstName, lastName, email, reportsTo, jobTitle from employees;
-- Interpretation: This values shows the basic details and information of all the employee

-- 3) count the number of employees holding each job title.
select jobTitle, count(employeeNumber) as number_of_employee from employees group by jobTitle order by number_of_employee;
-- Interpretation: This values will show thw total count of employees working in job 

-- 4) find the employees who don't have a manager (reports to is null)
select * from employees;
SELECT employeeNumber, firstName, lastName FROM employees WHERE reportsTo IS NULL;
-- Interpretation: The employee who don't have a manager that is only 1 employee don't have manager

-- 5) calculate total sale generated by each sales respresentative.
select salesRepEmployeeNumber, sum(quantityOrdered*priceEach) as total_sale from customers
join orders using (customerNumber)
join orderdetails using (orderNumber)
group by salesRepEmployeeNumber
order by total_sale;
-- Interpretation: This value will show the total sales generated by each sale representative with the help of representative number

-- 6) find the most profitable sales representative based on total sale.dual
select salesRepEmployeeNumber, sum(quantityOrdered*priceEach) as total_sale from customers
join orders using (customerNumber)
join orderdetails using (orderNumber)
group by salesRepEmployeeNumber
order by total_sale desc
limit 1;
-- Interpretation: This row shows the most profitable sales representative with the help of total sale

-- 7) find the names of all employees who have sold more than the average sales amount for their office.
SELECT e.employeeNumber, e.firstName, e.officeCode, AVG(od.quantityOrdered * od.priceEach) AS office_avg_sales
FROM employees e
JOIN customers c ON e.employeeNumber = c.salesRepEmployeeNumber
JOIN orders o ON c.customerNumber = o.customerNumber
JOIN orderdetails od ON o.orderNumber = od.orderNumber
GROUP BY e.employeeNumber, e.firstName, e.officeCode
HAVING AVG(od.quantityOrdered * od.priceEach) > (
    SELECT AVG(od2.quantityOrdered * od2.priceEach)
    FROM employees e2
    JOIN customers c2 ON e2.employeeNumber = c2.salesRepEmployeeNumber
    JOIN orders o2 ON c2.customerNumber = o2.customerNumber
    JOIN orderdetails od2 ON o2.orderNumber = od2.orderNumber
    WHERE e2.officeCode = e.officeCode
);
use modelcarsdb;

-- Interpretation: This shows names of all employees who have sold more than the average sales amount for their office.

-- Task 2 
-- 1) Find the average order amount for each customer
select customerName, avg(priceEach*quantityOrdered) as ord_amt from customers
join orders using(customerNumber)
join orderdetails using (orderNumber)
group by customerName
order by ord_amt desc;

select customerName, avg(amount) as amt from customers
join payments using (customerNumber)
group by customerName
order by amt desc;
-- Interpretation: This values will show the average order amount for each customer

-- 2) Find the number of order placed in each month.
select month(orderDate) as month, COUNT(*) AS num_orders from orders
group by month(orderDate);
-- Interpertation: This shows the number of order placed in each month

-- 3) Identify orders that are still pending shipment (status ='pending')
select * from orders where status='pending';
-- Interpretation: This show's there is on order status='pending' in shipments

-- 4) list orders along with customers details
select customerName, country, addressLine1, phone orderNumber, orderDate from customers
join orders using(customerNumber);
-- Interpretation: This show the customer order details

-- 5) retrieve the most recent orders (based on on order date)
select * from orders
order by orderDate desc
limit 1;
-- Interpretation: Tis show the most 3 recent orders

-- 6) Calculate total sales for each order.
select orderNumber, sum(quantityOrdered * priceEach) as total_sales from orders
join orderdetails using (orderNumber)
join products using (productCode)
group by orderNumber;
-- Interpretation: This value show the total sales for each order number from dataset

-- 7) Find the highest-value order based on total sales.
select orderNumber, productCode, sum(quantityOrdered * priceEach) as total_sales from orders
join orderdetails using (orderNumber)
join products using (productCode)
group by orderNumber, productCode
order by total_sales desc
limit 1;
-- Interpretation: This show the highest value order basedon total sales

-- 8) List all orders with their corresponding order details.
select orderNumber,orderDate,productName,productDescription,status,quantityOrdered,priceEach from orders
join orderdetails using (orderNumber)
join products using (productCode);
-- Interpretation: This all column will show the details of all orders with their corresponding order details.

-- 9) List the most frequently ordered products.
select productName, count(*) as ord_count from products
join orderdetails using(productCode)
group by productCode
order by ord_count desc;
-- interpretation: this value listed the most frequently ordered product

-- 10) Calculate total revenue for each order.
select orderNumber, productName, sum(quantityOrdered * priceEach) as total_revenue from orders
join orderdetails using (orderNumber)
join products using (productCode)
group by orderNumber, productName
order by total_revenue;
-- Interpretation: This table will show the total revenue for each order 

-- 11) Identify the most profitable orders based on total revenue.
select orderNumber, productName, sum(quantityOrdered * priceEach) as total_revenue from orders
join orderdetails using (orderNumber)
join products using (productCode)
group by orderNumber, productName
order by total_revenue desc
limit 3;
-- Interpertation : This show the most profitable order based on total revenue.

-- 12) List all orders with detailed product information.
select orderNumber,productName,productLine,buyPrice,orderDate,status,productCode from orders
join orderdetails using (orderNumber)
join products using (productCode);
-- This will show you the list of all order with detailed product infomation

-- 13) Identify orders with delayed shipping (shippedDate > requiredDate).
select * from orders
where shippedDate > requireddate;
-- Interpretation : This value is showing all the order which are delayed shipping on '2004-03-04'

-- 14) Find the most popular product combinations within orders.
select * from products order by 1;
select o1.productcode, o2.productcode, count(*) from orderdetails o1
join orderdetails o2 on o1.ordernumber=o2.ordernumber
and o1.productcode < o2.productcode
group by o1.productcode, o2.productcode
order by 3 desc
limit 1;
-- Interpretation: This shows the most popular product combining with orders.

-- 15) Calculate revenue for each order and identify the top 10 most profitable
select ordernumber, sum(quantityordered*(priceeach-products.buyprice)) as revenue from orderdetails
join products using (productcode)
group by ordernumber
order by 2 desc
limit 10;
-- Interpretation: This shows the revenue for each order and the top 10 profitable 

-- 16) Create a trigger that automatically updates a customer's credit limit after a new order is placed, reducing it by the order total.
DELIMITER //
CREATE TRIGGER after_order_insert
AFTER INSERT ON orders
FOR EACH ROW
BEGIN
DECLARE order_total DECIMAL(10,2);
SELECT SUM(od.quantityOrdered * od.priceEach) INTO order_total
FROM orderdetails od
WHERE od.orderNumber = NEW.orderNumber;
UPDATE customers
SET creditLimit = creditLimit - order_total
WHERE customerNumber = NEW.customerNumber;
END
//
DELIMITER ;
SELECT * FROM customers;
SELECT * FROM orderdetails;
SELECT * FROM orders;
-- Interpretation: a trigger that automatically updates a customers credit limit after a new order is placed

-- 17) Create a trigger that logs product quantity changes whenever an order detail is inserted or updated.
DELIMITER //
CREATE TABLE product_quantity (
    log_id INT PRIMARY KEY AUTO_INCREMENT,
    productCode INT NOT NULL,
    old_quantity INT,
    new_quantity INT,
    change_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
CREATE TRIGGER after_order_items_insert_update
AFTER INSERT ON orderdetails
FOR EACH ROW
BEGIN
    INSERT INTO product_quantity (productCode, old_quantity, new_quantity)
    VALUES (90, 46, 98);
END //
DELIMITER ;
select * from product_quantity;
drop table product_quantity;
-- Interpretation: this show the value and created trigger that logs product quantity changes whenever an order detail is inserted or updated.

 
 
 
 
 
 
 
CREATE VIEW customer AS
SELECT customers.customerName, orders.orderNumber, orders.orderDate
FROM customers
JOIN Orders ON customers.customerNumber = orders.customerNumber;

select * from customer;